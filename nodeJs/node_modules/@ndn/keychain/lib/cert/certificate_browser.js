import { __importDefault, __importStar } from "tslib";
import { Data, SigInfo } from "@ndn/packet";
import { assert } from "@ndn/util";
import _cjsDefaultImport0 from "@yoursunny/asn1"; const asn1 = __importDefault(_cjsDefaultImport0).default;
import * as CertNaming from "../naming_browser.js";
import { ContentTypeKEY } from "./an_browser.js";
import { ValidityPeriod } from "./validity-period_browser.js";
/**
 * NDN Certificate v2.
 * This type is immutable.
 */
export class Certificate {
    data;
    validity;
    static fromData(data) {
        const { name, contentType, sigInfo } = data;
        if (!CertNaming.isCertName(name)) {
            throw new Error(`${name} is not a certificate name`);
        }
        if (contentType !== ContentTypeKEY) {
            throw new Error("ContentType must be KEY");
        }
        const validity = ValidityPeriod.get(sigInfo);
        if (!validity) {
            throw new Error("ValidityPeriod is missing");
        }
        const cert = new Certificate(data, validity);
        return cert;
    }
    constructor(data, validity) {
        this.data = data;
        this.validity = validity;
    }
    get name() { return this.data.name; }
    get issuer() {
        return this.data.sigInfo.keyLocator?.name;
    }
    get isSelfSigned() {
        return this.issuer?.isPrefixOf(this.name) ?? false;
    }
    /** Ensure certificate is within validity period. */
    checkValidity(now = Date.now()) {
        if (!this.validity.includes(now)) {
            throw new Error(`certificate ${this.name} has expired`);
        }
    }
    /** Public key in SubjectPublicKeyInfo (SPKI) binary format. */
    get publicKeySpki() {
        return this.data.content;
    }
    /** Import SPKI as public key. */
    async importPublicKey(algoList) {
        const der = asn1.parseVerbose(this.publicKeySpki);
        const errs = [];
        for (const algo of algoList) {
            if (!algo.importSpki) {
                continue;
            }
            try {
                return [algo, await algo.importSpki(this.publicKeySpki, der)];
            }
            catch (err) {
                errs.push(`${algo.uuid}: ${err}`);
            }
        }
        throw new Error(`cannot import key\n${errs.join("\n")}\n(you may need to specify an algoList with more algorithms)`);
    }
}
(function (Certificate) {
    /** Build a certificate from fields. */
    async function build({ name, freshness = 3600000, validity, publicKeySpki, signer, }) {
        assert(CertNaming.isCertName(name));
        const data = new Data(name, Data.ContentType(ContentTypeKEY), Data.FreshnessPeriod(freshness));
        data.sigInfo = new SigInfo();
        ValidityPeriod.set(data.sigInfo, validity);
        data.content = publicKeySpki;
        await signer.sign(data);
        return Certificate.fromData(data);
    }
    Certificate.build = build;
    /** Create a certificated signed by issuer. */
    async function issue(opts) {
        let { issuerPrivateKey: signer, issuerId, publicKey: { name, spki } } = opts;
        name = CertNaming.makeCertName(name, { issuerId });
        if (!spki) {
            throw new Error("options.publicKey.spki unavailable");
        }
        return build({ ...opts, name, publicKeySpki: spki, signer });
    }
    Certificate.issue = issue;
    /** Create a self-signed certificate. */
    async function selfSign(opts) {
        const { privateKey, publicKey: { name: pubName } } = opts;
        if (!privateKey.name.equals(pubName)) {
            throw new Error("key pair mismatch");
        }
        return issue({
            validity: ValidityPeriod.MAX,
            ...opts,
            issuerId: CertNaming.ISSUER_SELF,
            issuerPrivateKey: privateKey,
        });
    }
    Certificate.selfSign = selfSign;
})(Certificate || (Certificate = {}));
