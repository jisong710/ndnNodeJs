import { assert, crypto } from "@ndn/util";
import { createDecrypter, createEncrypter, createSigner, createVerifier, CryptoAlgorithm, KeyKind } from "../key/mod_browser.js";
import { StoreBase } from "./store-base_browser.js";
/** KV store of named key pairs. */
export class KeyStore extends StoreBase {
    constructor(provider, algoList) {
        super(provider);
        this.loader = new KeyStore.Loader(false, algoList);
    }
    loader;
    async get(name) {
        const stored = await this.getValue(name);
        return this.loader.loadKey(name, stored);
    }
    async insert(name, stored) {
        const algo = this.loader.findAlgo(stored.algo);
        if (!algo) {
            throw new Error(`unknown algorithm uuid ${stored.algo}`);
        }
        if (stored.publicKeySpki) {
            stored.publicKeySpki = this.bufferToStorable(stored.publicKeySpki);
        }
        await this.insertValue(name, stored);
    }
}
(function (KeyStore) {
    /** Loaded key pair. */
    class KeyPair {
        name;
        algo;
        pvt;
        pub;
        constructor(name, algo, pvt, pub) {
            this.name = name;
            this.algo = algo;
            this.pvt = pvt;
            this.pub = pub;
        }
        get signer() {
            assert(CryptoAlgorithm.isSigning(this.algo), "signer is only available with a signing algorithm");
            return createSigner(this.name, this.algo, this.pvt);
        }
        get verifier() {
            assert(CryptoAlgorithm.isSigning(this.algo), "verifier is only available with a signing algorithm");
            return createVerifier(this.name, this.algo, this.pub);
        }
        get encrypter() {
            assert(CryptoAlgorithm.isEncryption(this.algo), "encrypter is only available with an encryption algorithm");
            return createEncrypter(this.name, this.algo, this.pub);
        }
        get decrypter() {
            assert(CryptoAlgorithm.isEncryption(this.algo), "decrypter is only available with an encryption algorithm");
            return createDecrypter(this.name, this.algo, this.pvt);
        }
        get publicKey() {
            assert(CryptoAlgorithm.isAsym(this.algo), "publicKey is only available with an asymmetric algorithm");
            return {
                name: this.name,
                [KeyKind]: "public",
                spki: this.pub.spki,
            };
        }
    }
    KeyStore.KeyPair = KeyPair;
    /** Helper to load key pair from stored format. */
    class Loader {
        extractable;
        algoList;
        constructor(extractable, algoList) {
            this.extractable = extractable;
            this.algoList = algoList;
        }
        findAlgo(uuid) {
            return this.algoList.find((algo) => algo.uuid === uuid);
        }
        async loadKey(name, stored) {
            const algo = this.findAlgo(stored.algo);
            if (!algo) {
                throw new Error(`unknown algorithm uuid ${stored.algo}`);
            }
            if (CryptoAlgorithm.isAsym(algo)) {
                return this.loadAsymmetric(name, algo, stored);
            }
            assert(CryptoAlgorithm.isSym(algo));
            return this.loadSymmetric(name, algo, stored);
        }
        async loadAsymmetric(name, algo, { info, jwkImportParams, privateKey, publicKey, publicKeySpki, }) {
            if (!privateKey || !publicKey || !publicKeySpki) {
                throw new Error("bad algorithm or key");
            }
            if (jwkImportParams) {
                [privateKey, publicKey] = await Promise.all([
                    crypto.subtle.importKey("jwk", privateKey, jwkImportParams, this.extractable, algo.keyUsages.private),
                    crypto.subtle.importKey("jwk", publicKey, jwkImportParams, this.extractable, algo.keyUsages.public),
                ]);
            }
            return new KeyPair(name, algo, { info, privateKey: privateKey }, { info, publicKey: publicKey, spki: StoreBase.bufferFromStorable(publicKeySpki) });
        }
        async loadSymmetric(name, algo, { info, jwkImportParams, secretKey, }) {
            if (!secretKey) {
                throw new Error("bad algorithm or key");
            }
            if (jwkImportParams) {
                secretKey = await crypto.subtle.importKey("jwk", secretKey, jwkImportParams, this.extractable, algo.keyUsages.secret);
            }
            const key = { info, secretKey: secretKey };
            return new KeyPair(name, algo, key, key);
        }
    }
    KeyStore.Loader = Loader;
})(KeyStore || (KeyStore = {}));
