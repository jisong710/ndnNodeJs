import { Name } from "@ndn/packet";
import { CryptoAlgorithmListSlim } from "../algolist/mod_browser.js";
import * as CertNaming from "../naming_browser.js";
import { CertStore } from "./cert-store_browser.js";
import { KeyStore } from "./key-store_browser.js";
import { MemoryStoreProvider } from "./store-base_browser.js";
import { openStores } from "./stores_browser.js";
/** Storage of own private keys and certificates. */
export class KeyChain {
    /**
     * Retrieve key by key name.
     * @param typ "signer", "verifier", etc.
     */
    async getKey(name, typ) {
        const keyPair = await this.getKeyPair(name);
        return keyPair[typ];
    }
    /**
     * Create a signer from keys and certificates in the KeyChain.
     * @param name subject name, key name, or certificate name.
     *
     * @li If name is a certificate name, sign with the corresponding private key,
     *     and use the specified certificate name as KeyLocator.
     * @li If name is a key name, sign with the specified private key.
     *     If a non-self-signed certificate exists for this key, use the certificate name as KeyLocator.
     *     Otherwise, use the key name as KeyLocator.
     * @li If name is neither certificate name nor key name, it is interpreted as a subject name.
     *     A non-self-signed certificate of this subject name is preferred.
     *     If such a certificate does not exist, use any key of this subject name.
     * @li If prefixMatch is true, name can also be interpreted as a prefix of the subject name.
     */
    async getSigner(name, { prefixMatch = false, fallback, useKeyNameKeyLocator = false } = {}) {
        const useFallback = (err) => {
            switch (typeof fallback) {
                case "function": {
                    return fallback(name, this, err);
                }
                case "undefined": {
                    throw new Error(`signer ${name} not found ${err}`);
                }
                default: {
                    return fallback;
                }
            }
        };
        const changeKeyLocator = (signer, certName) => {
            if (certName && !useKeyNameKeyLocator) {
                return signer.withKeyLocator(certName);
            }
            return signer;
        };
        if (CertNaming.isCertName(name)) {
            let signer;
            try {
                signer = await this.getKey(CertNaming.toKeyName(name), "signer");
            }
            catch (err) {
                return useFallback(err);
            }
            return changeKeyLocator(signer, name);
        }
        if (CertNaming.isKeyName(name)) {
            let signer;
            let certName;
            try {
                [signer, certName] = await Promise.all([
                    this.getKey(name, "signer"),
                    this.findSignerCertName(name, ({ keyName }) => name.equals(keyName)),
                ]);
            }
            catch (err) {
                return useFallback(err);
            }
            return changeKeyLocator(signer, certName);
        }
        const certName = await this.findSignerCertName(name, ({ subjectName }) => prefixMatch || name.equals(subjectName));
        if (certName) {
            const signer = await this.getKey(CertNaming.toKeyName(certName), "signer");
            return changeKeyLocator(signer, certName);
        }
        let keyNames = await this.listKeys(name);
        if (!prefixMatch) {
            keyNames = keyNames.filter((keyName) => {
                const { subjectName } = CertNaming.parseKeyName(keyName);
                return name.equals(subjectName);
            });
        }
        if (keyNames.length > 0) {
            return this.getKey(keyNames[0], "signer");
        }
        return useFallback();
    }
    async findSignerCertName(prefix, filter) {
        const certName_ = (await this.listCerts(prefix)).find((certName) => {
            const parsed = CertNaming.parseCertName(certName);
            return !parsed.issuerId.equals(CertNaming.ISSUER_SELF) && filter(parsed);
        });
        return certName_;
    }
}
class KeyChainImpl extends KeyChain {
    keys;
    certs;
    constructor(keys, certs) {
        super();
        this.keys = keys;
        this.certs = certs;
    }
    get needJwk() { return !this.keys.canSClone; }
    async listKeys(prefix = new Name()) {
        return (await this.keys.list()).filter((n) => prefix.isPrefixOf(n));
    }
    async getKeyPair(name) {
        return this.keys.get(name);
    }
    async insertKey(name, stored) {
        await this.keys.insert(name, stored);
    }
    async deleteKey(name) {
        const certs = await this.listCerts(name);
        await Promise.all(certs.map((cert) => this.certs.erase(cert)));
        await this.keys.erase(name);
    }
    async listCerts(prefix = new Name()) {
        return (await this.certs.list()).filter((n) => prefix.isPrefixOf(n));
    }
    async getCert(name) {
        return this.certs.get(name);
    }
    async insertCert(cert) {
        await this.getKeyPair(CertNaming.toKeyName(cert.name)); // ensure key exists
        await this.certs.insert(cert);
    }
    async deleteCert(name) {
        await this.certs.erase(name);
    }
}
(function (KeyChain) {
    function open(arg1, arg2 = CryptoAlgorithmListSlim) {
        if (typeof arg1 === "string") {
            return new KeyChainImpl(...openStores(arg1, arg2));
        }
        return new KeyChainImpl(arg1, arg2);
    }
    KeyChain.open = open;
    /**
     * Create an in-memory ephemeral KeyChain.
     * @param algoList list of recognized algorithms.
     *                 Use CryptoAlgorithmListFull for all algorithms, at the cost of larger bundle size.
     */
    function createTemp(algoList = CryptoAlgorithmListSlim) {
        return new KeyChainImpl(new KeyStore(new MemoryStoreProvider(), algoList), new CertStore(new MemoryStoreProvider()));
    }
    KeyChain.createTemp = createTemp;
})(KeyChain || (KeyChain = {}));
