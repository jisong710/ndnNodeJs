"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.whitelist = whitelist;
exports.regex = regex;
exports.array = array;
exports.nonNegativeInteger = exports.negativeInteger = exports.nonPositiveInteger = exports.positiveInteger = exports.port = exports.ipAddress = exports.url = exports.email = exports.float = exports.integer = exports.boolean = exports.string = void 0;

var _validator = _interopRequireDefault(require("validator"));

var _EnvironmentVariableError = _interopRequireDefault(require("./EnvironmentVariableError"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Parses a string.
 */
const string = serializedValue => serializedValue;
/**
 * Parses a boolean. parsed values are case insensitive.
 * Truthy values: true, 1, yes.
 * Falsy values: false, 0, no.
 */


exports.string = string;

const boolean = serializedValue => {
  const truthyValues = ['true', '1', 'yes', 'on'];
  const falsyValues = ['false', '0', 'no', 'off'];
  const lowercaseSerializedValue = serializedValue.toLowerCase();

  if (truthyValues.includes(lowercaseSerializedValue)) {
    return true;
  }

  if (falsyValues.includes(lowercaseSerializedValue)) {
    return false;
  }

  const validValuesString = [...truthyValues, ...falsyValues].join(' ');
  throw new _EnvironmentVariableError.default(`value is not valid. Valid values: ${validValuesString}`);
};
/**
 * Parses an integer.
 */


exports.boolean = boolean;

const integer = serializedValue => {
  if (!_validator.default.isInt(serializedValue)) {
    throw new _EnvironmentVariableError.default('value is not an integer');
  }

  const value = Number.parseInt(serializedValue, 10);
  return value;
};
/**
 * Parses a float.
 */


exports.integer = integer;

const float = serializedValue => {
  const value = Number.parseFloat(serializedValue);

  if (Number.isNaN(value)) {
    throw new _EnvironmentVariableError.default('value is not a number');
  }

  return value;
};
/**
 * Parses an email.
 */


exports.float = float;

const email = serializedValue => {
  const value = serializedValue;

  if (!_validator.default.isEmail(value)) {
    throw new _EnvironmentVariableError.default('value is not an email');
  }

  return value;
};
/**
 * Parses a URL.
 */


exports.email = email;

const url = serializedValue => {
  const value = serializedValue;

  if (!_validator.default.isURL(value)) {
    throw new _EnvironmentVariableError.default('value is not an URL');
  }

  return value;
};
/**
 * Parses an IP address.
 */


exports.url = url;

const ipAddress = serializedValue => {
  const value = serializedValue;

  if (!_validator.default.isIP(value)) {
    throw new _EnvironmentVariableError.default('value is not an IP address');
  }

  return value;
};
/**
 * Parses a port number.
 */


exports.ipAddress = ipAddress;

const port = serializedValue => {
  if (!_validator.default.isPort(serializedValue)) {
    throw new _EnvironmentVariableError.default('value is not a port');
  }

  const value = Number.parseInt(serializedValue, 10);
  return value;
};
/**
 * Returns a parser that parses a value from
 * a list of whitelisted values.
 */


exports.port = port;

function whitelist(whitelistedValues) {
  const whitelistParser = serializedValue => {
    const value = serializedValue;

    if (!whitelistedValues.includes(value)) {
      const whitelistedValuesString = whitelistedValues.map(whitelistedValue => `'${whitelistedValue}'`).join(', ');
      throw new _EnvironmentVariableError.default(`value is not in the whitelist. Valid values are ${whitelistedValuesString}`);
    }

    return value;
  };

  return whitelistParser;
}
/**
 * Returns a parser that parses a value matching a regular expression.
 */


function regex(pattern) {
  const regexParser = serializedValue => {
    const value = serializedValue;

    if (!pattern.test(value)) {
      throw new _EnvironmentVariableError.default(`value does not match regex ${pattern.toString()}`);
    }

    return value;
  };

  return regexParser;
}

const defaultArraySeparator = ',';
/**
 * Returns a parser that parses a list of values of a type.
 */

function array(args) {
  const separator = args.separator || defaultArraySeparator;

  const arrayParser = serializedArray => {
    const serializedValues = serializedArray.split(separator);
    const values = serializedValues.map(serializedValue => args.parser(serializedValue));
    return values;
  };

  return arrayParser;
}
/**
 * Parses a positive integer.
 */


const positiveInteger = serializedValue => {
  const value = integer(serializedValue);

  if (value <= 0) {
    throw new _EnvironmentVariableError.default('value is not positive');
  }

  return value;
};
/**
 * Parses a non-positive integer.
 */


exports.positiveInteger = positiveInteger;

const nonPositiveInteger = serializedValue => {
  const value = integer(serializedValue);

  if (value > 0) {
    throw new _EnvironmentVariableError.default('value is positive');
  }

  return value;
};
/**
 * Parses a negative integer.
 */


exports.nonPositiveInteger = nonPositiveInteger;

const negativeInteger = serializedValue => {
  const value = integer(serializedValue);

  if (value >= 0) {
    throw new _EnvironmentVariableError.default('value is not negative');
  }

  return value;
};
/**
 * Parses a non-negative integer.
 */


exports.negativeInteger = negativeInteger;

const nonNegativeInteger = serializedValue => {
  const value = integer(serializedValue);

  if (value < 0) {
    throw new _EnvironmentVariableError.default('value is negative');
  }

  return value;
};

exports.nonNegativeInteger = nonNegativeInteger;
//# sourceMappingURL=parsers.js.map