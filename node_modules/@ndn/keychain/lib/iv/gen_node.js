import { assert } from "@ndn/util";
/**
 * Initialization Vector generator.
 *
 * The .wrap() method creates an LLEncrypt.Key or LLEncrypt that generates an IV for each message
 * before encryption, and updates the internal state of this class after encryption. Typically, a
 * separate IVGen instance should be used for each key.
 *
 * If a message passed for encryption already has an IV associated, it would bypass this class: in
 * that case, the IV is not checked and the internal state is not updated.
 */
export class IvGen {
    ivLength;
    constructor(ivLength) {
        this.ivLength = ivLength;
        assert(ivLength > 0);
    }
    wrap(arg1) {
        if (typeof arg1.llEncrypt === "function") {
            return this.wrapKey(arg1);
        }
        return this.wrapLLEncrypt(arg1);
    }
    wrapKey(key) {
        const f = this.wrapLLEncrypt((...args) => key.llEncrypt(...args));
        return new Proxy(key, {
            get(target, prop, receiver) {
                if (prop === "llEncrypt") {
                    return f;
                }
                return Reflect.get(target, prop, receiver);
            },
        });
    }
    wrapLLEncrypt(f) {
        return async (params) => {
            if (params.iv) {
                return f(params);
            }
            params.iv = this.generate();
            const result = await f(params);
            this.update(params.plaintext.length, result.ciphertext.length);
            return result;
        };
    }
    /** Update internal state after a message is encrypted.. */
    update(plaintextLength, ciphertextLength) {
        void plaintextLength;
        void ciphertextLength;
    }
}
