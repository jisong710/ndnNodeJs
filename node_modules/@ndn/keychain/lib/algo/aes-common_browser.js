import { crypto } from "@ndn/util";
export var AesKeyLength;
(function (AesKeyLength) {
    AesKeyLength.Default = 128;
    AesKeyLength.Choices = [128, 192, 256];
})(AesKeyLength || (AesKeyLength = {}));
/** AES block size in octets. */
export const AesBlockSize = 16;
export class AesCommon {
    keyUsages = { secret: ["encrypt", "decrypt"] };
    modifyParams(params, info) {
        void params;
        void info;
    }
    makeAesKeyGenParams({ length = AesKeyLength.Default }) {
        return {
            name: this.name,
            length,
        };
    }
    async cryptoGenerate(genParams, extractable) {
        let secretKey;
        if (genParams.importRaw) {
            secretKey = await crypto.subtle.importKey("raw", genParams.importRaw, this.name, extractable, this.keyUsages.secret);
        }
        else {
            secretKey = await crypto.subtle.generateKey(this.makeAesKeyGenParams(genParams), extractable, this.keyUsages.secret);
        }
        const info = Object.fromEntries(Object.entries(this.defaultInfo)
            .map(([key, dflt]) => [key, genParams[key] ?? dflt]));
        return {
            secretKey,
            jwkImportParams: this.name,
            info,
        };
    }
    check(iv, additionalData) {
        if (iv?.byteLength !== this.ivLength) {
            throw new Error("bad IV");
        }
        if (additionalData && !this.allowAdditionalData) {
            throw new Error("cannot use additionalData");
        }
    }
    makeLLEncrypt(key) {
        const { secretKey, info } = key;
        return this.getIvGen(key).wrap(async ({ plaintext, iv, additionalData, }) => {
            this.check(iv, additionalData);
            const params = {
                name: this.name,
                iv,
                additionalData,
            };
            this.modifyParams(params, info);
            const encrypted = await crypto.subtle.encrypt(params, secretKey, plaintext);
            return {
                ciphertext: new Uint8Array(encrypted, 0, encrypted.byteLength - this.tagSize),
                iv,
                authenticationTag: this.tagSize > 0 ? new Uint8Array(encrypted, encrypted.byteLength - this.tagSize) : undefined,
            };
        });
    }
    makeLLDecrypt({ secretKey, info }) {
        return async ({ ciphertext, iv, authenticationTag, additionalData, }) => {
            this.check(iv, additionalData);
            if ((authenticationTag?.length ?? 0) !== this.tagSize) {
                throw new Error("bad authenticationTag");
            }
            let encrypted = ciphertext;
            if (this.tagSize > 0) {
                encrypted = new Uint8Array(ciphertext.length + this.tagSize);
                encrypted.set(ciphertext, 0);
                encrypted.set(authenticationTag, ciphertext.length);
            }
            const params = {
                name: this.name,
                iv,
                additionalData,
            };
            this.modifyParams(params, info);
            const plaintext = new Uint8Array(await crypto.subtle.decrypt(params, secretKey, encrypted));
            return { plaintext };
        };
    }
}
