import { connectToNetwork, connectToRouter } from "@ndn/autoconfig";
import { openFace as dpdkOpenFace } from "@ndn/dpdkmgmt";
import { FwTracer } from "@ndn/fw";
import { enableNfdPrefixReg } from "@ndn/nfdmgmt";
import { UnixTransport } from "@ndn/node-transport";
import { Closers } from "@ndn/util";
import { env } from "./env_browser.js";
import { exitClosers } from "./exit_browser.js";
import { getSignerImpl, openKeyChain } from "./keychain_browser.js";
if (env.pktTrace) {
    FwTracer.enable();
}
async function makeFace() {
    let autoconfigPreferTcp = false;
    let dpdkScheme = "udp";
    switch (env.uplink.protocol) {
        case "autoconfig-tcp:": {
            autoconfigPreferTcp = true;
        }
        // fallthrough
        case "autoconfig:": {
            try {
                const faces = await connectToNetwork({
                    mtu: env.mtu,
                    preferTcp: autoconfigPreferTcp,
                });
                return [faces[0], true];
            }
            catch {
                throw new Error("autoconfig unavailable, set uplink in NDNTS_UPLINK");
            }
        }
        case "tcp:": {
            return [(await connectToRouter(env.uplink.host, { preferTcp: true, testConnection: false })).face, true];
        }
        case "udp:": {
            return [(await connectToRouter(env.uplink.host, { preferTcp: false, mtu: env.mtu, testConnection: false })).face, true];
        }
        case "unix:": {
            const face = await UnixTransport.createFace({}, env.uplink.pathname);
            return [face, true];
        }
        case "ndndpdk-memif:": {
            dpdkScheme = "memif";
        }
        // fallthrough
        case "ndndpdk-udp:":
        case "ndndpdk:": {
            const face = await dpdkOpenFace({
                gqlServer: env.dpdkGql,
                localHost: env.dpdkLocal,
                scheme: dpdkScheme,
                memif: {
                    socketPath: env.dpdkMemifSocketPath,
                    dataroom: env.mtu,
                },
            });
            return [face, false];
        }
        default: {
            throw new Error(`unknown protocol ${env.uplink.protocol} in NDNTS_UPLINK`);
        }
    }
}
let theUplinks;
/** Open the uplinks specified by NDNTS_UPLINK environ. */
export async function openUplinks({ autoClose = true } = {}) {
    if (!theUplinks) {
        const [face, nfd] = await makeFace();
        if (nfd && env.nfdReg) {
            const signerName = env.nfdRegKey ?? env.key;
            const [signer, klName] = await getSignerImpl(signerName);
            enableNfdPrefixReg(face, {
                signer,
                preloadCertName: klName ?? signerName,
                preloadFromKeyChain: openKeyChain(),
            });
        }
        theUplinks = new Closers();
        theUplinks.push(face);
        if (autoClose) {
            exitClosers.push(theUplinks);
        }
    }
    return theUplinks;
}
/** Close the uplinks. */
export function closeUplinks() {
    theUplinks?.close();
    theUplinks = undefined;
}
