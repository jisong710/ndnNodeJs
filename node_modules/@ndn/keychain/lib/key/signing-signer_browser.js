import { LLSign, Signer } from "@ndn/packet";
import { assert } from "@ndn/util";
import * as CertNaming from "../naming_browser.js";
import { KeyKind } from "./types_browser.js";
class PlainCryptoSigner {
    constructor(algo, key) {
        const pvtkey = key;
        if (pvtkey.privateKey) {
            this[KeyKind] = "private";
            this.llSign = algo.makeLLSign(pvtkey);
        }
        else {
            this[KeyKind] = "secret";
            this.llSign = algo.makeLLSign(key);
        }
        this.sigType = algo.sigType;
    }
    [KeyKind];
    sigType;
    llSign;
    sign(pkt) {
        return this.signWithKeyLocator(pkt, undefined);
    }
    signWithKeyLocator(pkt, keyLocator) {
        Signer.putSigInfo(pkt, this.sigType, keyLocator);
        return pkt[LLSign.OP]((input) => this.llSign(input));
    }
}
class NamedCryptoSigner extends PlainCryptoSigner {
    name;
    constructor(name, algo, key) {
        super(algo, key);
        this.name = name;
        assert(CertNaming.isKeyName(name), `bad key name ${name}`);
    }
    sign(pkt) {
        return this.signWithKeyLocator(pkt, this.name);
    }
    withKeyLocator(keyLocator) {
        return {
            sign: (pkt) => this.signWithKeyLocator(pkt, keyLocator),
        };
    }
}
export function createSigner(arg1, arg2, arg3) {
    if (arg3) {
        return new NamedCryptoSigner(arg1, arg2, arg3);
    }
    return new PlainCryptoSigner(arg1, arg2);
}
