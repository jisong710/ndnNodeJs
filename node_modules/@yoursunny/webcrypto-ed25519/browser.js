import * as ed from "@noble/ed25519";
import * as asn1 from "@yoursunny/asn1";
// @ts-expect-error no typing
import { toBase64Url as b64encode, toBuffer as b64decode } from "b64u-lite";
import { C, isEd25519Algorithm } from "./common.js";
export const Ed25519Algorithm = {
    name: C.wicgAlgorithm,
};
function asUint8Array(b) {
    if (b instanceof Uint8Array) {
        return b;
    }
    if (b instanceof ArrayBuffer) {
        return new Uint8Array(b);
    }
    return new Uint8Array(b.buffer, b.byteOffset, b.byteLength);
}
function asArrayBuffer(b) {
    if (b.byteLength === b.buffer.byteLength) {
        return b.buffer;
    }
    return b.buffer.slice(b.byteOffset, b.byteLength);
}
const slot = "8d9df0f7-1363-4d2c-8152-ce4ed78f27d8";
class Ponyfill {
    constructor(super_) {
        this.super_ = super_;
        this.orig_ = {};
        for (const method of ["generateKey", "exportKey", "importKey", "encrypt", "decrypt", "wrapKey", "unwrapKey", "deriveBits", "deriveKey", "sign", "verify", "digest"]) {
            if (this[method]) {
                this.orig_[method] = super_[method];
            }
            else {
                this[method] = super_[method].bind(super_);
            }
        }
    }
    async generateKey(algorithm, extractable, keyUsages) {
        if (isEd25519Algorithm(algorithm)) {
            const pvt = ed.utils.randomPrivateKey();
            const pub = await ed.getPublicKey(pvt);
            const usages = Array.from(keyUsages);
            const privateKey = {
                algorithm,
                extractable,
                type: "private",
                usages,
                [slot]: pvt,
            };
            const publicKey = {
                algorithm,
                extractable: true,
                type: "public",
                usages,
                [slot]: pub,
            };
            return { privateKey, publicKey };
        }
        return this.orig_.generateKey.apply(this.super_, arguments);
    }
    async exportKey(format, key) {
        if (isEd25519Algorithm(key.algorithm) && key.extractable) {
            const raw = key[slot];
            switch (format) {
                case "jwk": {
                    const jwk = {
                        kty: C.kty,
                        crv: C.crv,
                    };
                    if (key.type === "public") {
                        jwk.x = b64encode(raw);
                    }
                    else {
                        jwk.d = b64encode(raw);
                        jwk.x = b64encode(await ed.getPublicKey(raw));
                    }
                    return jwk;
                }
                case "spki": {
                    return asArrayBuffer(asn1.pack([
                        "30",
                        [
                            ["30", [["06", "2B6570"]]],
                            ["03", raw],
                        ],
                    ]));
                }
            }
        }
        return this.orig_.exportKey.apply(this.super_, arguments);
    }
    async importKey(format, keyData, algorithm, extractable, keyUsages) {
        if (isEd25519Algorithm(algorithm)) {
            const usages = Array.from(keyUsages);
            switch (format) {
                case "jwk": {
                    const jwk = keyData;
                    if (jwk.kty !== C.kty || jwk.crv !== C.crv || !jwk.x) {
                        break;
                    }
                    const key = {
                        algorithm,
                        extractable,
                        type: jwk.d ? "private" : "public",
                        usages,
                        [slot]: b64decode(jwk.d ?? jwk.x),
                    };
                    return key;
                }
                case "spki": {
                    const der = asn1.parseVerbose(asUint8Array(keyData));
                    const algo = der.children?.[0]?.children?.[0]?.value;
                    const raw = der.children?.[1]?.value;
                    if (!(algo instanceof Uint8Array) || ed.utils.bytesToHex(algo) !== C.oid || !(raw instanceof Uint8Array)) {
                        break;
                    }
                    const key = {
                        algorithm,
                        extractable: true,
                        type: "public",
                        usages,
                        [slot]: raw,
                    };
                    return key;
                }
            }
        }
        return this.orig_.importKey.apply(this.super_, arguments);
    }
    async sign(algorithm, key, data) {
        if (isEd25519Algorithm(algorithm) && isEd25519Algorithm(key.algorithm) && key.type === "private" && key.usages.includes("sign")) {
            return asArrayBuffer(await ed.sign(asUint8Array(data), key[slot]));
        }
        return this.orig_.sign.apply(this.super_, arguments);
    }
    async verify(algorithm, key, signature, data) {
        if (isEd25519Algorithm(algorithm) && isEd25519Algorithm(key.algorithm) && key.type === "public" && key.usages.includes("verify")) {
            return ed.verify(asUint8Array(signature), asUint8Array(data), key[slot]);
        }
        return this.orig_.verify.apply(this.super_, arguments);
    }
}
export function ponyfillEd25519(subtle = crypto.subtle) {
    return new Ponyfill(subtle);
}
export function polyfillEd25519() {
    Object.defineProperty(globalThis.crypto, "subtle", {
        value: ponyfillEd25519(),
        configurable: true,
    });
}
//# sourceMappingURL=browser.js.map