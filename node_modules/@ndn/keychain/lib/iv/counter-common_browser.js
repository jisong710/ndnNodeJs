import { assert, crypto, toHex } from "@ndn/util";
export function parseCounterIvOptions({ ivLength, fixedBits = 0, fixed: fixedInput, counterBits, }) {
    assert(ivLength > 0);
    assert(fixedBits >= 0);
    assert(counterBits > 0);
    const ivBits = ivLength * 8;
    const randomBits = ivBits - fixedBits - counterBits;
    assert(randomBits >= 0);
    let fixedMask = 0n;
    let fixed = 0n;
    if (fixedBits > 0) {
        fixedMask = BigInt(`0b${"1".repeat(fixedBits)}${"0".repeat(randomBits + counterBits)}`);
        switch (typeof fixedInput) {
            case "bigint": {
                fixed = fixedInput;
                break;
            }
            case "object": {
                fixed = BigInt(`0x${toHex(fixedInput)}`);
                break;
            }
            default: {
                throw new Error("bad CounterIvOptions.fixed");
            }
        }
        fixed <<= BigInt(randomBits + counterBits);
        fixed &= fixedMask;
    }
    let randomMask = 0n;
    let random = 0n;
    if (randomBits > 0) {
        randomMask = BigInt(`0b${"1".repeat(randomBits)}${"0".repeat(counterBits)}`);
        const randomBuffer = crypto.getRandomValues(new Uint8Array(ivLength));
        random = BigInt(`0x${toHex(randomBuffer)}`);
        random &= randomMask;
    }
    const maxCounter = BigInt(`0b1${"0".repeat(counterBits)}`);
    const counterMask = maxCounter - 1n;
    return {
        ivBits,
        fixedBits,
        fixedMask,
        fixed,
        randomBits,
        randomMask,
        random,
        counterMask,
        maxCounter,
    };
}
export function throwCounterIvErrorIf(cond) {
    if (cond) {
        throw new Error("CounterIv error");
    }
}
export class CounterIncrement {
    maxCounter;
    constructor(blockSize, maxCounter) {
        this.maxCounter = maxCounter;
        assert(blockSize > 0);
        this.blockSize = BigInt(blockSize);
    }
    blockSize;
    counter = 0n;
    appendBlocks(plaintextLength, ciphertextLength) {
        const nOctets = BigInt(Math.max(plaintextLength, ciphertextLength));
        this.counter += (nOctets + this.blockSize - 1n) / this.blockSize;
        throwCounterIvErrorIf(this.counter > this.maxCounter);
    }
}
