import { assert, toHex } from "@ndn/util";
import { IvChecker } from "./checker_node.js";
import { CounterIncrement, parseCounterIvOptions, throwCounterIvErrorIf } from "./counter-common_node.js";
/** Check IVs of fixed+random+counter structure to detect duplication. */
export class CounterIvChecker extends IvChecker {
    constructor(opts) {
        super(opts.ivLength);
        const { fixedMask, fixed, randomMask, counterMask, maxCounter, } = parseCounterIvOptions(opts);
        const { requireSameRandom = false, blockSize, } = opts;
        this.fixedMask = fixedMask;
        this.randomMask = randomMask;
        this.counterMask = counterMask;
        this.fixed = fixed;
        this.requireSameRandom = requireSameRandom;
        this.ci = new CounterIncrement(blockSize, maxCounter);
    }
    fixedMask;
    randomMask;
    counterMask;
    fixed;
    requireSameRandom;
    lastRandom;
    ci;
    extract(iv) {
        assert(iv.length === this.ivLength);
        const value = BigInt(`0x${toHex(iv)}`);
        return {
            fixed: value & this.fixedMask,
            random: value & this.randomMask,
            counter: value & this.counterMask,
        };
    }
    check(iv, plaintextLength, ciphertextLength) {
        const { fixed, random, counter } = this.extract(iv);
        throwCounterIvErrorIf(fixed !== this.fixed);
        throwCounterIvErrorIf(counter < this.ci.counter);
        if (this.requireSameRandom) {
            this.lastRandom ??= random;
            throwCounterIvErrorIf(this.lastRandom !== random);
        }
        this.ci.counter = counter;
        this.ci.appendBlocks(plaintextLength, ciphertextLength);
    }
}
