import { __importDefault, __importStar } from "tslib";
import { SigType, Verifier } from "@ndn/packet";
import { crypto, fromHex, toHex } from "@ndn/util";
import _cjsDefaultImport0 from "@yoursunny/asn1"; const asn1 = __importDefault(_cjsDefaultImport0).default;
import { extractSpkiAlgorithm } from "./impl-spki_node.js";
const SignVerifyParams = { name: "ECDSA", hash: "SHA-256" };
function makeGenParams(curve) {
    return { name: "ECDSA", namedCurve: curve };
}
const PointSizes = {
    "P-256": 32,
    "P-384": 48,
    "P-521": 66,
};
const NamedCurveOids = {
    "2A8648CE3D030107": "P-256",
    "2B81040022": "P-384",
    "2B81040023": "P-521", // 1.3.132.0.35
};
export var EcCurve;
(function (EcCurve) {
    EcCurve.Default = "P-256";
    EcCurve.Choices = Object.keys(PointSizes);
})(EcCurve || (EcCurve = {}));
function toUintHex(array) {
    let msb;
    for (msb = 0; msb < array.byteLength - 1; ++msb) {
        if (array[msb]) {
            break;
        }
    }
    return toHex(array.subarray(msb));
}
/** Sha256WithEcdsa signing algorithm. */
export const ECDSA = {
    uuid: "a81b3696-65e5-4f4c-bb45-14125472321b",
    sigType: SigType.Sha256WithEcdsa,
    keyUsages: {
        private: ["sign"],
        public: ["verify"],
    },
    async cryptoGenerate({ curve = EcCurve.Default, importPkcs8 }, extractable) {
        const params = makeGenParams(curve);
        let privateKey;
        let publicKey;
        if (importPkcs8) {
            const [pkcs8, spki] = importPkcs8;
            [privateKey, publicKey] = await Promise.all([
                crypto.subtle.importKey("pkcs8", pkcs8, params, extractable, this.keyUsages.private),
                crypto.subtle.importKey("spki", spki, params, true, this.keyUsages.public),
            ]);
        }
        else {
            ({ privateKey, publicKey } = await crypto.subtle.generateKey(params, extractable, [...this.keyUsages.private, ...this.keyUsages.public]));
        }
        const spki = new Uint8Array(await crypto.subtle.exportKey("spki", publicKey));
        return {
            privateKey,
            publicKey,
            jwkImportParams: params,
            spki,
            info: { curve },
        };
    },
    async importSpki(spki, der) {
        if (extractSpkiAlgorithm(der) !== "2A8648CE3D0201") { // 1.2.840.10045.2.1
            throw new Error("not ECDSA key");
        }
        // SubjectPublicKeyInfo.algorithm.parameter
        const ecp = der.children?.[0]?.children?.[1];
        const curve = ecp?.type === 0x06 && ecp.value && NamedCurveOids[toHex(ecp.value)];
        if (!curve) {
            throw new Error("invalid EC namedCurve");
        }
        const params = makeGenParams(curve);
        const publicKey = await crypto.subtle.importKey("spki", spki, params, true, this.keyUsages.public);
        return {
            publicKey,
            spki,
            info: { curve },
        };
    },
    makeLLSign({ privateKey, info: { curve } }) {
        return async (input) => {
            const raw = await crypto.subtle.sign(SignVerifyParams, privateKey, input);
            const pointSize = PointSizes[curve];
            return fromHex(asn1.Any("30", asn1.UInt(toUintHex(new Uint8Array(raw, 0, pointSize))), asn1.UInt(toUintHex(new Uint8Array(raw, pointSize)))));
        };
    },
    makeLLVerify({ publicKey, info: { curve } }) {
        return async (input, sig) => {
            const pointSize = PointSizes[curve];
            const der = asn1.parseVerbose(sig);
            const r = der.children?.[0]?.value;
            const s = der.children?.[1]?.value;
            if (!r || !s || r.byteLength > pointSize || s.byteLength > pointSize) {
                Verifier.throwOnBadSig(false);
            }
            const raw = new Uint8Array(2 * pointSize);
            raw.set(r, pointSize - r.byteLength);
            raw.set(s, 2 * pointSize - s.byteLength);
            const ok = await crypto.subtle.verify(SignVerifyParams, publicKey, raw, input);
            Verifier.throwOnBadSig(ok);
        };
    },
};
