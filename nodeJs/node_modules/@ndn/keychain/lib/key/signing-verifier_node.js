import { KeyLocator, LLVerify, Verifier } from "@ndn/packet";
import { assert } from "@ndn/util";
import { SigningAlgorithmListSlim } from "../algolist/mod_node.js";
import * as CertNaming from "../naming_node.js";
import { ImportCertCached, isPublicSecretKey } from "./impl-import-cert_node.js";
import { KeyKind } from "./types_node.js";
class PlainCryptoVerifier {
    constructor(algo, key) {
        const pubkey = key;
        if (pubkey.publicKey) {
            this[KeyKind] = "public";
            this.llVerify = algo.makeLLVerify(pubkey);
            this.spki = pubkey.spki;
        }
        else {
            this[KeyKind] = "secret";
            this.llVerify = algo.makeLLVerify(key);
        }
        this.sigType = algo.sigType;
    }
    [KeyKind];
    sigType;
    llVerify;
    spki;
    verify(pkt) {
        Verifier.checkSigType(pkt, this.sigType);
        return pkt[LLVerify.OP]((input, sig) => this.llVerify(input, sig));
    }
}
class NamedCryptoVerifier extends PlainCryptoVerifier {
    name;
    constructor(name, algo, key) {
        super(algo, key);
        this.name = name;
        assert(CertNaming.isKeyName(name), `bad key name ${name}`);
    }
    verify(pkt) {
        const klName = KeyLocator.mustGetName(pkt.sigInfo?.keyLocator);
        if (!this.name.isPrefixOf(klName)) {
            throw new Error(`KeyLocator ${klName} does not match key ${this.name}`);
        }
        return super.verify(pkt);
    }
}
export function createVerifier(arg1, arg2 = {}, arg3) {
    if (arg3) {
        return new NamedCryptoVerifier(arg1, arg2, arg3);
    }
    if (isPublicSecretKey(arg2)) {
        return new PlainCryptoVerifier(arg1, arg2);
    }
    return certVerifiers.importCert(arg1, arg2);
}
const certVerifiers = new ImportCertCached(NamedCryptoVerifier, SigningAlgorithmListSlim);
