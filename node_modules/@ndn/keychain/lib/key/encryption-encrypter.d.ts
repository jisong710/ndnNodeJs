import type { LLEncrypt, Name } from "@ndn/packet";
import type { Certificate, ValidityPeriod } from "../cert/mod.js";
import { type CryptoAlgorithm, type EncryptionAlgorithm, type NamedEncrypter } from "./types.js";
/** Create a plain encrypter from crypto key. */
export declare function createEncrypter<I>(algo: EncryptionAlgorithm<I>, key: CryptoAlgorithm.PublicSecretKey<I>): LLEncrypt.Key;
/** Create a named encrypter from crypto key. */
export declare function createEncrypter<I, Asym extends boolean>(name: Name, algo: EncryptionAlgorithm<I, Asym>, key: CryptoAlgorithm.PublicSecretKey<I>): NamedEncrypter<Asym>;
/** Create a named encrypter from certificate public key. */
export declare function createEncrypter(cert: Certificate, opts?: createEncrypter.ImportCertOptions): Promise<NamedEncrypter.PublicKey>;
export declare namespace createEncrypter {
    /** createEncrypter options when importing public key from a certificate. */
    interface ImportCertOptions {
        /**
         * List of recognized algorithms.
         * Default is EncryptionAlgorithmListSlim.
         * Use EncryptionAlgorithmListFull for all algorithms, at the cost of larger bundle size.
         */
        algoList?: readonly EncryptionAlgorithm[];
        /**
         * Whether to check certificate ValidityPeriod.
         * Default is true, which throws an error if current timestamp is not within ValidityPeriod.
         */
        checkValidity?: boolean;
        /**
         * Current timestamp for checking ValidityPeriod.
         * Default is Date.now().
         */
        now?: ValidityPeriod.TimestampInput;
    }
}
