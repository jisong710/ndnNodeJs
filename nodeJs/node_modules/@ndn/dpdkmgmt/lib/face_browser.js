import { once } from "events";
import * as net from "net";
import * as path from "path";
import { Forwarder } from "@ndn/fw";
import { L3Face } from "@ndn/l3face";
import { joinHostPort, splitHostPort, udp_helper, UdpTransport } from "@ndn/node-transport";
import { gql, GraphQLClient } from "graphql-request";
import { MemifTransport } from "./memif-transport_browser.js";
import { NdndpdkPrefixReg } from "./prefix-reg_browser.js";
const DefaultGqlServer = "http://127.0.0.1:3030";
async function detectLocalAddress(gqlServer) {
    const { host, port = 80 } = splitHostPort(new URL(gqlServer).host);
    if (host === "127.0.0.1") {
        return host;
    }
    const tcpConn = net.connect(port, host);
    await once(tcpConn, "connect");
    const { localAddress } = tcpConn;
    tcpConn.destroy();
    return localAddress;
}
async function openFaceImpl({ gqlServer = "http://127.0.0.1:3030", fw = Forwarder.getDefault(), addRoutes, attributes = {}, }, locator, prepareTransport) {
    const client = new GraphQLClient(gqlServer);
    const { createFace: { id, locator: loc } } = await client.request(gql `
    mutation createFace($locator: JSON!) {
      createFace(locator: $locator) {
        id
        locator
      }
    }
  `, {
        locator,
    });
    const prefixReg = new NdndpdkPrefixReg(client, id);
    const cleanup = async () => {
        prefixReg.disable();
        await client.request(gql `
      mutation delete($id: ID!) {
        delete(id: $id)
      }
    `, {
            id,
        });
    };
    let transport;
    let mtu;
    try {
        [transport, mtu] = await prepareTransport(loc);
    }
    catch (err) {
        await cleanup();
        throw err;
    }
    prefixReg.enable(fw);
    const face = fw.addFace(new L3Face(transport, {
        advertiseFrom: false,
        describe: `NDN-DPDK(${id})`,
        ...attributes,
    }, {
        mtu,
    }));
    L3Face.processAddRoutes(face, addRoutes);
    face.on("close", cleanup);
    return face;
}
async function openFaceUdp(opts) {
    let { gqlServer = DefaultGqlServer, localHost, udp: udpOptionsInput, } = opts;
    localHost ??= await detectLocalAddress(gqlServer);
    const sock = await udp_helper.openSocket({
        bind: { address: localHost },
        ...udpOptionsInput,
    });
    try {
        return await openFaceImpl(opts, {
            scheme: "udp",
            remote: joinHostPort(localHost, sock.address().port),
        }, async (loc) => {
            const { host, port } = splitHostPort(loc.local ?? "");
            if (!host || !port) {
                throw new Error(`unexpected locator: ${JSON.stringify(loc)}`);
            }
            await udp_helper.connect(sock, { host, port });
            return [new UdpTransport(sock), 1450];
        });
    }
    catch (err) {
        sock.close();
        throw err;
    }
}
async function openFaceMemif(opts) {
    const { memif: { socketPath = "/run/ndn", dataroom = 2048, ringCapacity = 1024, } = {}, } = opts;
    const socketName = path.join(socketPath, `NDNts-memif-${process.pid}-${Date.now()}.sock`);
    return openFaceImpl(opts, {
        scheme: "memif",
        role: "server",
        socketName,
        socketOwner: [process.getuid(), process.getgid()],
        id: 0,
        dataroom,
        ringCapacity,
    }, async () => {
        const transport = await MemifTransport.connect({
            role: "client",
            socketName,
            id: 0,
            dataroom,
            ringCapacity,
        });
        return [transport, dataroom];
    });
}
/** Open a face on NDN-DPDK. */
export async function openFace(opts = {}) {
    const { scheme = "udp", } = opts;
    switch (scheme) {
        case "udp": {
            return openFaceUdp(opts);
        }
        case "memif": {
            return openFaceMemif(opts);
        }
        default: {
            throw new Error(`unknown scheme ${scheme}`);
        }
    }
}
