import { Component, TT } from "@ndn/packet";
import { Encoder, NNI } from "@ndn/tlv";
class Typed {
    tt;
    constructor(tt) {
        this.tt = tt;
    }
    match(comp) {
        return comp.type === this.tt;
    }
}
class TypedString extends Typed {
    create(v) {
        return new Component(this.tt, v);
    }
    parse(comp) {
        return comp.text;
    }
}
class TypedNumberBase extends Typed {
    altUriPrefix;
    altUriRegex;
    constructor(tt, altUriPrefix) {
        super(tt);
        this.altUriPrefix = altUriPrefix;
        this.altUriRegex = new RegExp(`^${altUriPrefix}(\\d+)$`);
    }
    create(v) {
        return new Component(this.tt, Encoder.encode(NNI(v), 8));
    }
    match(comp) {
        return super.match(comp) && NNI.isValidLength(comp.length);
    }
    parseRaw(comp) {
        return NNI.decode(comp.value, { big: true });
    }
    toAltUri(comp) {
        return `${this.altUriPrefix}${this.parseRaw(comp)}`;
    }
    fromAltUri(input) {
        const m = this.altUriRegex.exec(input);
        if (!m) {
            return undefined;
        }
        return this.create(BigInt(m[1]));
    }
}
class TypedNumber extends TypedNumberBase {
    parse(comp) {
        return NNI.decode(comp.value);
    }
}
class TypedBig extends TypedNumberBase {
    parse(comp) {
        return NNI.decode(comp.value, { big: true });
    }
}
class TypedNumberBig extends TypedNumber {
    constructor(...args) {
        super(...args);
        this.big = new TypedBig(...args);
    }
    big;
}
class TypedTimestamp extends TypedNumber {
    unit;
    max;
    constructor(tt, unit, max = Number.MAX_SAFE_INTEGER) {
        super(tt, "t=");
        this.unit = unit;
        this.max = max;
    }
    create(v) {
        if (v instanceof Date) {
            v = v.getTime() * 1000;
        }
        else {
            v = Number(v) * this.unit;
        }
        this.checkMax(v);
        return super.create(v);
    }
    parse(comp) {
        const v = super.parse(comp);
        this.checkMax(v);
        return v / this.unit;
    }
    checkMax(v) {
        if (v > this.max) {
            throw new Error("timestamp number too large");
        }
    }
}
function makeTimestampConvention(tt) {
    const ms = new TypedTimestamp(tt, 1000, 8787511468039992);
    const us = new TypedTimestamp(tt, 1);
    return Object.assign(ms, { ms, us });
}
/**
 * GenericNameComponent enclosing a number.
 *
 * This is not really a naming convention, but it's used in several protocols.
 */
export const GenericNumber = new TypedNumberBig(TT.GenericNameComponent, "");
/** KeywordNameComponent (rev2 & rev3), interpreted as string. */
export const Keyword = new TypedString(0x20);
/** SegmentNameComponent (rev2), interpreted as number. */
export const Segment2 = new TypedNumberBig(0x21, "seg=");
/** SegmentNameComponent (rev3), interpreted as number. */
export const Segment3 = new TypedNumberBig(0x32, "seg=");
/** SegmentNameComponent (default format, currently rev3). */
export const Segment = Segment3;
/** ByteOffsetNameComponent (rev2), interpreted as number. */
export const ByteOffset2 = new TypedNumberBig(0x22, "off=");
/** ByteOffsetNameComponent (rev3), interpreted as number. */
export const ByteOffset3 = new TypedNumberBig(0x34, "off=");
/** ByteOffsetNameComponent (default format, currently rev3). */
export const ByteOffset = ByteOffset3;
/** VersionNameComponent (rev2), interpreted as number. */
export const Version2 = new TypedNumberBig(0x23, "v=");
/** VersionNameComponent (rev3), interpreted as number. */
export const Version3 = new TypedNumberBig(0x36, "v=");
/** VersionNameComponent (default format, currently rev3). */
export const Version = Version3;
/** TimestampNameComponent (rev2), interpreted as number in milliseconds. */
export const Timestamp2 = makeTimestampConvention(0x24);
/** TimestampNameComponent (rev3), interpreted as number in milliseconds. */
export const Timestamp3 = makeTimestampConvention(0x38);
/** TimestampNameComponent (default format, currently rev3). */
export const Timestamp = Timestamp3;
/** SequenceNumNameComponent (rev2), interpreted as number. */
export const SequenceNum2 = new TypedNumberBig(0x25, "seq=");
/** SequenceNumNameComponent (rev3), interpreted as number. */
export const SequenceNum3 = new TypedNumberBig(0x3A, "seq=");
/** SequenceNumNameComponent (default format, currently rev3). */
export const SequenceNum = SequenceNum3;
