import { __importDefault, __importStar } from "tslib";
import { Endpoint } from "@ndn/endpoint";
import { ReadvertiseDestination, TapFace } from "@ndn/fw";
import { Certificate } from "@ndn/keychain";
import { Interest, NameMap } from "@ndn/packet";
import { Closers } from "@ndn/util";
import _cjsDefaultImport0 from "obliterator/map.js"; const map = __importDefault(_cjsDefaultImport0).default;
import { ControlCommand } from "./control-command_node.js";
class NfdPrefixReg extends ReadvertiseDestination {
    face;
    commandOptions;
    routeOptions;
    refreshInterval;
    preloadCertName;
    preloadFromKeyChain;
    preloadInterestLifetime;
    preloadCerts = new NameMap();
    constructor(face, opts) {
        super(opts.retry);
        this.face = face;
        this.commandOptions = {
            commandPrefix: ControlCommand.getPrefix(face.attributes.local),
            ...opts,
        };
        this.routeOptions = {
            origin: 65,
            cost: 0,
            flags: 0x02,
            ...opts,
        };
        this.refreshInterval = opts.refreshInterval ?? 300000;
        this.preloadCertName = opts.preloadCertName;
        this.preloadFromKeyChain = opts.preloadFromKeyChain;
        this.preloadInterestLifetime = Interest.Lifetime(opts.preloadInterestLifetime ?? 500);
        face.on("up", this.handleFaceUp);
        face.once("close", () => this.disable());
    }
    disable() {
        this.face.off("up", this.handleFaceUp);
        super.disable();
    }
    async tap() {
        const tapFace = TapFace.create(this.face);
        tapFace.addRoute("/");
        const endpoint = new Endpoint({
            announcement: false,
            describe: "NfdPrefixReg",
            fw: tapFace.fw,
        });
        const preloadProducers = await this.preload(endpoint);
        const closers = new Closers();
        closers.push(...map(preloadProducers, ([, p]) => p), tapFace);
        return [
            { ...this.commandOptions, endpoint },
            closers.close,
        ];
    }
    async preload(endpoint) {
        const producers = new NameMap();
        let name = this.preloadCertName;
        while (name && !producers.has(name)) {
            try {
                const cert = await this.retrievePreload(endpoint, name);
                this.preloadCerts.set(name, cert);
                producers.set(name, endpoint.produce(name, async () => cert.data));
                name = cert.issuer;
            }
            catch {
                name = undefined;
            }
        }
        return producers;
    }
    async retrievePreload(endpoint, name) {
        const cert = this.preloadCerts.get(name);
        if (cert) {
            return cert;
        }
        if (this.preloadFromKeyChain) {
            try {
                return await this.preloadFromKeyChain.getCert(name);
            }
            catch { }
        }
        const interest = new Interest(name, Interest.CanBePrefix, this.preloadInterestLifetime);
        const data = await endpoint.consume(interest);
        return Certificate.fromData(data);
    }
    handleFaceUp = () => {
        for (const [name, { status, state }] of this.table) {
            if (status === ReadvertiseDestination.Status.ADVERTISED) {
                this.scheduleRefresh(name, state, 100);
            }
        }
    };
    async doAdvertise(name, state) {
        const [opts, untap] = await this.tap();
        try {
            const cr = await ControlCommand.call("rib/register", {
                name,
                origin: this.routeOptions.origin,
                cost: this.routeOptions.cost,
                flags: this.routeOptions.flags,
            }, opts);
            if (cr.statusCode !== 200) {
                throw new Error(`${cr.statusCode} ${cr.statusText}`);
            }
        }
        finally {
            untap();
        }
        if (this.refreshInterval !== false) {
            this.scheduleRefresh(name, state, this.refreshInterval);
        }
    }
    scheduleRefresh(name, state, after) {
        clearTimeout(state.refreshTimer);
        state.refreshTimer = setTimeout(() => {
            const record = this.table.get(name);
            if (record?.status === ReadvertiseDestination.Status.ADVERTISED) {
                record.status = ReadvertiseDestination.Status.ADVERTISING;
                this.restart(name, record);
            }
        }, after);
    }
    async doWithdraw(name, state) {
        clearTimeout(state.refreshTimer);
        state.refreshTimer = undefined;
        if (this.closed) {
            return;
        }
        const [opts, untap] = await this.tap();
        try {
            const cr = await ControlCommand.call("rib/unregister", {
                name,
                origin: this.routeOptions.origin,
            }, opts);
            if (cr.statusCode !== 200) {
                throw new Error(`${cr.statusCode} ${cr.statusText}`);
            }
        }
        finally {
            untap();
        }
    }
}
/**
 * Enable prefix registration via NFD management protocol.
 * @param face face connected to NFD.
 * @param opts options.
 */
export function enableNfdPrefixReg(face, opts = {}) {
    new NfdPrefixReg(face, opts).enable(face.fw);
}
